import { Command } from 'commander';
import chalk from 'chalk';
import { createQuestion } from './create.js';
import clipboard from 'clipboardy';
import { writeFile } from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const DATA_TS = path.resolve('src/data/blocks.ts');

export function blockCommand(): Command {
  const cmd = new Command('block');
  cmd.description('Manage block ID definitions');

  cmd
    .command('add')
    .description('Add a custom block ID to src/data/blocks.ts/json')
    .action(async () => {
      // load existing blocks from the compiled data module if present
      let list: string[] = [];
      try {
        const mod = await import(fileURLToPath(new URL('../data/blocks.js', import.meta.url)));
        list = (mod?.BLOCKS || mod?.default || []) as string[];
      } catch {
        // fallback: try importing .ts (when running with ts-node)
        try {
          const mod = await import(fileURLToPath(new URL('../data/blocks.ts', import.meta.url)));
          list = (mod?.BLOCKS || mod?.default || []) as string[];
        } catch {
          list = [];
        }
      }

      while (true) {
        const id = (
          await createQuestion(chalk.cyan('Block ID to add (e.g. minecraft:my_block): '))
        ).trim();
        if (!id) {
          console.log(chalk.yellow('Cancelled. No ID entered.'));
          return;
        }
        const normalized = id.startsWith('minecraft:') ? id.slice(10) : id;
        if (list.includes(normalized) || list.includes(id)) {
          console.log(chalk.yellow(`ID ${id} already exists.`));
          const again =
            (await createQuestion(chalk.cyan('Add another? (y/N): '))).toLowerCase() === 'y';
          if (!again) return;
          continue;
        }

        // basic validation
        if (!/^[a-z0-9_:-]+$/.test(id)) {
          console.log(
            chalk.red(
              'Invalid ID format. Allowed: lowercase letters, numbers, underscore, colon, hyphen.'
            )
          );
          continue;
        }

        list.push(normalized);
        list = Array.from(new Set(list)).sort();
        // write TS only
        const tsContent = `// Auto-generated by CLI block command\nexport const BLOCKS = ${JSON.stringify(list, null, 2)} as string[];\nexport default BLOCKS;\n`;
        await writeFile(DATA_TS, tsContent, 'utf8');
        console.log(chalk.green(`Added ${id} to ${DATA_TS}`));

        const again =
          (await createQuestion(chalk.cyan('Add another? (y/N): '))).toLowerCase() === 'y';
        if (!again) return;
      }
    });

  cmd
    .command('list')
    .description('List known block IDs')
    .action(async () => {
      try {
        const mod = await import(fileURLToPath(new URL('../data/blocks.js', import.meta.url)));
        const list = (mod?.BLOCKS || mod?.default || []) as string[];
        console.log(chalk.green(`Known block IDs (${list.length}):`));
        list.forEach((b) => console.log(` - minecraft:${b}`));
      } catch {
        console.log(
          chalk.red(
            'No blocks data found. Run scripts/generate-blocks.cjs or add some with `block add`'
          )
        );
      }
    });

  cmd
    .command('remove')
    .description('Remove a block ID from src/data/blocks.ts/json')
    .action(async () => {
      try {
        // import current list
        let list: string[] = [];
        try {
          const mod = await import(fileURLToPath(new URL('../data/blocks.js', import.meta.url)));
          list = (mod?.BLOCKS || mod?.default || []) as string[];
        } catch {
          try {
            const mod = await import(fileURLToPath(new URL('../data/blocks.ts', import.meta.url)));
            list = (mod?.BLOCKS || mod?.default || []) as string[];
          } catch {
            list = [];
          }
        }

        if (!list.length) {
          console.log(chalk.yellow('No block IDs to remove.'));
          return;
        }

        // use enquirer AutoComplete to pick
        const enquirerModule: any = await import('enquirer');
        const AutoComplete = enquirerModule.AutoComplete || enquirerModule.default?.AutoComplete;
        let pick = '';
        if (AutoComplete) {
          const ac = new AutoComplete({
            name: 'remove',
            message: 'Select block to remove:',
            limit: 10,
            choices: list.map((b) => ({ name: `minecraft:${b}`, value: b })),
          });
          try {
            pick = String(await ac.run());
          } catch {
            // fallback to text
            pick = (
              await createQuestion(chalk.cyan('Block ID to remove (e.g. minecraft:stone): '))
            ).trim();
            if (pick.startsWith('minecraft:')) pick = pick.slice(10);
          }
        } else {
          pick = (
            await createQuestion(chalk.cyan('Block ID to remove (e.g. minecraft:stone): '))
          ).trim();
          if (pick.startsWith('minecraft:')) pick = pick.slice(10);
        }

        if (!pick) return;
        const normalized = pick.startsWith('minecraft:') ? pick.slice(10) : pick;
        if (!list.includes(normalized)) {
          console.log(chalk.yellow(`ID ${pick} not found.`));
          return;
        }
        list = list.filter((x) => x !== normalized);
        // write TS only
        const tsContent = `// Auto-generated by CLI block command\nexport const BLOCKS = ${JSON.stringify(list.sort(), null, 2)} as string[];\nexport default BLOCKS;\n`;
        await writeFile(DATA_TS, tsContent, 'utf8');
        console.log(chalk.green(`Removed ${normalized} from ${DATA_TS}`));
      } catch {
        console.log(chalk.red('Failed to remove block ID'));
      }
    });

  cmd
    .command('search')
    .description('Search blocks by category and name')
    .action(async () => {
      // load current list
      let list: string[] = [];
      try {
        const mod = await import(fileURLToPath(new URL('../data/blocks.js', import.meta.url)));
        list = (mod?.BLOCKS || mod?.default || []) as string[];
      } catch {
        try {
          const mod = await import(fileURLToPath(new URL('../data/blocks.ts', import.meta.url)));
          list = (mod?.BLOCKS || mod?.default || []) as string[];
        } catch {
          list = [];
        }
      }

      if (!list.length) {
        console.log(
          chalk.red(
            'No blocks data found. Run scripts/generate-blocks.cjs or add some with `block add`'
          )
        );
        return;
      }

      const CATEGORY_KEYWORDS: Record<string, string[]> = {
        'Wood Blocks': [
          'oak_',
          'spruce_',
          'birch_',
          'jungle_',
          'acacia_',
          'dark_oak_',
          'mangrove_',
          'cherry_',
          'bamboo_',
          'planks',
          'log',
          'wood',
          'stripped_',
        ],
        'Wood Furniture': [
          'door',
          'trapdoor',
          'fence',
          'fence_gate',
          'hanging_sign',
          'sign',
          'button',
          'pressure_plate',
          'slab',
          'stairs',
        ],
        'Plants & Foliage': [
          'sapling',
          'leaves',
          'azalea',
          'flower',
          'fern',
          'grass',
          'tall_grass',
          'moss',
          'vine',
          'bamboo',
          'mangrove_propagule',
        ],
        Flowers: [
          'allium',
          'dandelion',
          'tulip',
          'rose',
          'peony',
          'blue_orchid',
          'oxeye_daisy',
          'poppy',
        ],
        'Fungi & Mushrooms': ['mushroom', 'mushroom_block', 'fungus'],
        'Ores & Minerals': [
          'ore',
          'ancient_debris',
          'deepslate',
          'raw_',
          'diamond_',
          'gold_',
          'iron_',
          'lapis_',
          'redstone_',
          'emerald_',
        ],
        'Stone & Basalt': [
          'stone',
          'andesite',
          'diorite',
          'granite',
          'tuff',
          'basalt',
          'deepslate',
          'cobbled_deepslate',
        ],
        'Building Blocks': [
          'stone',
          'brick',
          'bricks',
          'concrete',
          'concrete_powder',
          'terracotta',
          'tile',
          'polished',
          'smooth',
          'mosaic',
          'packed_',
          'cut_',
        ],
        'Slabs/Stairs/Walls': ['slab', 'stairs', 'wall'],
        Decorative: [
          'chiseled',
          'pillar',
          'carved',
          'banner',
          'sculk',
          'block',
          'bookshelf',
          'lantern',
          'torch',
          'lamp',
          'beacon',
        ],
        'Glass & Stained Glass': ['glass', 'stained_glass', 'glass_pane'],
        'Wool & Carpets': ['wool', 'carpet', 'bed'],
        'Redstone & Mechanisms': [
          'redstone',
          'comparator',
          'repeater',
          'lever',
          'observer',
          'piston',
          'sticky_piston',
          'hopper',
          'dropper',
          'dispenser',
          'note_block',
          'rail',
          'detector_rail',
          'powered_rail',
          'activator_rail',
        ],
        'Water/Lava/Natural': [
          'water',
          'lava',
          'dirt',
          'grass_block',
          'sand',
          'gravel',
          'clay',
          'moss',
          'soul_sand',
          'soul_soil',
        ],
        'Vegetation & Crops': [
          'wheat',
          'carrots',
          'potatoes',
          'beetroots',
          'sweet_berry',
          'sugar_cane',
          'cactus',
          'kelp',
        ],
        'Coral & Ocean': [
          'coral',
          'coral_block',
          'coral_fan',
          'coral_wall_fan',
          'sea_pickle',
          'seagrass',
        ],
        'Nether & End': [
          'netherrack',
          'nether',
          'end_stone',
          'end_portal',
          'end_rod',
          'respawn_anchor',
        ],
        Misc: [
          'chest',
          'barrel',
          'anvil',
          'ladder',
          'furnace',
          'enchanting_table',
          'crafting_table',
          'cauldron',
        ],
      };

      const categories = ['All', ...Object.keys(CATEGORY_KEYWORDS)];

      const enquirerModule: any = await import('enquirer');
      const Select = enquirerModule.Select || enquirerModule.default?.Select;
      const AutoComplete = enquirerModule.AutoComplete || enquirerModule.default?.AutoComplete;

      // Outer loop: allow re-selecting categories until user exits
      while (true) {
        let chosenCat = 'All';
        if (Select) {
          const sel = new Select({
            name: 'category',
            message: 'Choose category to search:',
            choices: categories,
          });
          try {
            chosenCat = String(await sel.run());
          } catch {
            chosenCat = 'All';
          }
        }

        let filtered = list;
        if (chosenCat !== 'All') {
          const keys = CATEGORY_KEYWORDS[chosenCat] || [];
          filtered = list.filter((b) => keys.some((k) => b.includes(k)));
        }

        if (!filtered.length) {
          console.log(chalk.yellow('No blocks match that category.'));
          // loop back to category selection
          continue;
        }

        // Single AutoComplete prompt per category. 'loop: false' prevents list wrapping.
        if (AutoComplete) {
          const choices = [
            { name: '<< Back to categories >>', value: '__BACK__' },
            ...filtered.map((b) => ({ name: `minecraft:${b}`, value: b })),
          ];
          const ac = new AutoComplete({
            name: 'block',
            message: `Search blocks (${filtered.length}) — type to filter:`,
            choices,
            limit: 20,
            loop: false,
          });
          try {
            const pick = String(await ac.run());
            if (pick === '__BACK__') {
              // immediately go back to category selection without additional prompts
              continue;
            }
            console.log(chalk.green('Selected:'), `minecraft:${pick}`);
            const yn = (
              await createQuestion(chalk.cyan('Copy selected block ID to clipboard? (y/N): '))
            ).trim();
            if (yn.toLowerCase() === 'y') {
              try {
                await clipboard.write(`minecraft:${pick}`);
                console.log(chalk.green('✓ Copied to clipboard: '), `minecraft:${pick}`);
              } catch {
                console.log(chalk.red('✗ Failed to copy to clipboard'));
              }
            } else {
              console.log(chalk.blue('Skipped copying to clipboard.'));
            }
            return;
          } catch {
            console.log(chalk.red('Search cancelled.'));
            return;
          }
        } else {
          // Fallback: substring search prompt
          const query = (await createQuestion(chalk.cyan('Search term (substring): '))).trim();
          if (!query) {
            // go back to category selection
            continue;
          }
          const matches = filtered.filter((b) => b.includes(query)).slice(0, 200);
          if (!matches.length) {
            console.log(chalk.yellow('No matches found.'));
            continue;
          }
          console.log(chalk.green(`Matches (${matches.length}):`));
          matches.forEach((m) => console.log(` - minecraft:${m}`));
          const pick = (
            await createQuestion(chalk.cyan('Enter block id to copy (or press Enter to go back): '))
          ).trim();
          if (!pick) {
            // go back to category selection
            continue;
          }
          const normalized = pick.startsWith('minecraft:') ? pick.slice(10) : pick;
          if (!matches.includes(normalized)) {
            console.log(chalk.yellow(`ID ${pick} not found in current matches.`));
            continue;
          }
          const yn = (
            await createQuestion(chalk.cyan('Copy selected block ID to clipboard? (y/N): '))
          ).trim();
          if (yn.toLowerCase() === 'y') {
            try {
              await clipboard.write(`minecraft:${normalized}`);
              console.log(chalk.green('✓ Copied to clipboard: '), `minecraft:${normalized}`);
            } catch {
              console.log(chalk.red('✗ Failed to copy to clipboard'));
            }
          } else {
            console.log(chalk.blue('Skipped copying to clipboard.'));
          }
          return;
        }
      }
    });

  return cmd;
}

export default blockCommand;
